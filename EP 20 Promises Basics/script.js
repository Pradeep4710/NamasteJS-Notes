const cart = ["shoes","shirt","shoes","pants","blazer","tie","watch"];

createOrder(cart); // orderID

proceedToPayment(orderId); // paymentInfo

showOrderSummary(paymentInfo); 

updateWalletBalance(paymentInfo);

// earlier in callbacks we used to wrap the proceedToPayment inside the createOrder API as it was dependent on the orderID which was generated by createOrder API, but there was an issue with this approach as it caused "Inversion of Controll" and it also causes the "Callback Hell" problem 

/* 
createOrder(cart, function(orderId){
    proceedToPayment(orderID, function(paymentInfo){
            updateWalletBalance();
        });
    });
*/

// it is also "called pyramid of doom"
// we also solve the Callback hell by using Promise Chaining:-

createOrder(cart)
    .then(function (orderId){
        return proceedToPayment(orderId)
    })
    .then(function (paymentInfo){
        return showOrderSummary(paymentInfo)
    })
    .then(function (paymentInfo){
        return updateWalletBalance(paymentInfo);
    });

// remember to always return a promise after a promise while creating a promise chain

// some developers preffer arrow functions, then our code will look like:-
createOrder(cart)
    .then(orderId => proceedToPayment(orderId))
    .then(paymentInfo => showOrderSummary(paymentInfo))
    .then(paymentInfo => updateWalletBalance(paymentInfo));


// Also to tackle Inversion of Controll issue we use promises

const promise = createOrder(cart);

// now when create this api it returns a promise, which is nothing but a data object with some value in it 
// {data: undefined }  and this data value will hold whatever the API returns to us after however much time the promise might take and fill that undefined data after recieving some data and by doing so we do not disturb the thread of Javascript engine

promise.then(function(orderId){
proceedToPayment(orderID);
});

// once we have the data inside the promise object, the callback function that we attach to the promise object, will get automatically called.

// this is a better approach as here we do not face the problem of "Inversion of Controll" 

// in callback method we used to pass a funciton inside a function
// whereas in case of promise, we attach a function to promise which calls the function as soon as the data is present inside the promise object

// also, it does not cause over or under calling of a function and call is exactly once as we have the controll of the code and not some external function

// lets create actial promise funciton

const GithubAPI = "https://api.github.com/users/Pradeep4710"

const user = fetch(GithubAPI);

console.log(user);

// now if we check console, it will log the promise as pending, whereas if we check the promise itself, it says fulfilled, it occurs because when we console.log the promise is still in the state of retrieving the data whereas the promise object in browser gets updated regularly
// also this only occurs in chrome browser and v8 engine other browser may have different outputs

// we attach a callback to check what the promise has returned

user.then(function(data){
    console.log(data);
})



// how to answer in Interview??

// what is a promise in JS?
// => Promise is an object representing the eventual completion of an asynchronous operation.

// why promises are important?
// => avoid callback hells and 